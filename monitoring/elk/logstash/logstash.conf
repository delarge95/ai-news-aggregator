input {
  # Logs del backend (FastAPI)
  beats {
    port => 5044
  }
  
  # Logs de aplicación Python
  tcp {
    port => 5000
    codec => json_lines
  }
  
  # Logs de contenedor
  syslog {
    port => 514
  }
}

filter {
  # Parsear logs de FastAPI
  if [fields][service] == "ai-news-backend" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} - %{LOGLEVEL:level} - %{DATA:logger} - %{GREEDYDATA:log_message}" }
      tag_on_failure => [ "_grokparsefailure" ]
    }
    
    # Extraer información de requests HTTP
    if [log_message] =~ /HTTP/ {
      grok {
        match => { "log_message" => "HTTP %{NUMBER:http_status:int} %{DATA:http_method} %{URIPATH:http_path}" }
      }
    }
    
    # Extraer duración de requests
    if [log_message] =~ /duration/ {
      grok {
        match => { "log_message" => "duration=%{NUMBER:duration:float}s" }
      }
    }
  }
  
  # Parsear logs de Celery
  if [fields][service] == "celery" {
    grok {
      match => { "message" => "Task %{WORD:task_name}\[%{UUID:task_id}\] %{GREEDYDATA:task_info}" }
      tag_on_failure => [ "_grokparsefailure" ]
    }
    
    if [task_info] =~ /SUCCESS/ {
      mutate {
        add_tag => [ "task_success" ]
        add_field => { "task_status" => "success" }
      }
    }
    
    if [task_info] =~ /FAILURE/ {
      mutate {
        add_tag => [ "task_failure" ]
        add_field => { "task_status" => "failure" }
      }
    }
    
    if [task_info] =~ /duration=%{NUMBER:task_duration:float}s/ {
      mutate {
        convert => { "task_duration" => "float" }
      }
    }
  }
  
  # Parsear logs de contenedor
  if [docker] {
    mutate {
      add_field => { "docker_container" => "%{[docker][container][name]}" }
      add_field => { "docker_image" => "%{[docker][container][image]}" }
    }
  }
  
  # Extraer información de errores
  if [level] == "ERROR" or [level] == "CRITICAL" {
    mutate {
      add_tag => [ "error" ]
    }
    
    # Extraer stack traces
    if [log_message] =~ /\n/ {
      mutate {
        split => { "log_message" => "\n" }
      }
    }
  }
  
  # Agregar timestamp si no existe
  if ![timestamp] {
    date {
      match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS" ]
    }
  }
  
  # Limpiar campos vacíos
  mutate {
    remove_field => [ "host", "agent", "ecs", "input", "log", "tags", "@version" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "ai-news-logs-%{+YYYY.MM.dd}"
    template => "ai-news-logs-template.json"
    template_name => "ai-news-logs"
    template_overwrite => true
    
    # Índices específicos por tipo de log
    if [fields][service] == "ai-news-backend" {
      index => "ai-news-backend-%{+YYYY.MM.dd}"
    } else if [fields][service] == "celery" {
      index => "ai-news-celery-%{+YYYY.MM.dd}"
    } else if [docker] {
      index => "ai-news-containers-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (comentar en producción)
  # stdout { codec => rubydebug }
}